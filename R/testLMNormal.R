#' Apply Goodness of Fit Test to Residuals of a Linear Model
#'
#' @description This function takes y as the response variable and x as the explanatory variable or design matrix
#' to test the normality of residuals in a linear model with the goodness of fit test.
#' It returns Cramer-von Mises statistic along with approximate pvalue for the test.
#'
#' @param x is either a vector of length n or a design matrix with n rows and p columns.
#'
#' @param y is a vector with the same number of observations or number of rows as x.
#'
#' @param fit If you have already applied your linear model, instead of passing your
#' data to the function, you can simply pass your fit object generated by
#' \code{\link{lm}} function. The default value of fit is NULL. If a fit object is provided, x and y will be
#' ignored. The testLMNormal function then will test if the residuals follow a Normal distribution.
#' The software will check to make sure the fit object is returned from lm function
#' Also make sure to ask lm function to return the design matrix and response variable used.
#' You can control this by setting x = TRUE and y = TRUE in lm function.
#'
#' To read more about this see the help documentation for \code{\link{lm}} function.
#'

#' @param ngrid The number of equally spaced points to discritize the (0,1) interval to estimate the covariance
#' of the process.
#'
#' @param gridpit A boolean variable indicating if probability transformed values should be used to discritize
#' the (0,1) interval to estimate the covariance of the stochastic process.
#' If TRUE, ngrid is ignored and (0,1) interval is divided based on probability inverse transformed values.
#' If FALSE (default value), (0,1) is divided into ngrid equally spaced points to estimate process.
#'
#' @param hessian A Boolean indicator to control if Hessian matrix should be used in estimation of Fisher information matrix.
#' If False (the default value), the Fisher information matrix is estimated by the observed score function.
#' If TRUE, the Fisher information matrix is estimated by the observed Hessian Matrix.
#'
#' @param method a character string to indicate which statistics to calculate.
#' The possible values are 'cvm' for Cramer-von Mises and 'ad' for Anderson-Darling.
#' The default value is 'cvm'.
#'
#' @return A list of two.
#' - Statistic: The Cramer-von-Mises statistic.
#' - pvalue: The approximated pvalue for the GoF test based on EDF.
#' @export
#'
#' @examples
#' set.seed(123)
#' n <- 50
#' p <- 5
#' xmatrix <- matrix( runif(n*p), nrow = n, ncol = p)
#' e <- runif(n)
#' b <- runif(p)
#' y <- xmatrix %*% b + e
#' testLMNormal(x = xmatrix, y)
#' # Or pass myfit object directly:
#' myfit <- lm(y ~ 0 + xmatrix, x = TRUE, y = TRUE)
#' testLMNormal(fit = myfit)
testLMNormal = function(x, y, fit = NULL, ngrid = length(y), gridpit = FALSE, hessian = FALSE, method = 'cvm'){


  # Check if fitted object if provided or not
  if( is.null(fit) ){

    if( is.vector(x) ){
      n           <- length(x)
      int         <- rep(1, n)
      x           <- cbind(int,x)
      colnames(x) <- c('Intercept', 'x')
    }

    if( is.matrix(x) ){
      n <- nrow(x)
    }

    temp   <- applyLMNormal(x = x, y = y)
    Score  <- temp$Score
    pit    <- temp$pit
    par    <- temp$par

    # Get Fisher information matrix
    if( hessian ){
      fisher <- getObservedHessMatrixinLMNormal(x, y, par)
    }else{
      fisher <- (n-1)*var(Score)/n
    }

    # Get Eigen values
    if( gridpit ){
      ev    <- getEigenValues(S = Score, FI = fisher, pit, me = method)
    }else{
      ev    <- getEigenValues_manualGrid(S = Score, FI = fisher, pit, M = ngrid, me = method)
    }

    # Get C-v-M statistic
    cvm      <- getCvMStatistic(pit)

    # Get pvalue
    pvalue  <- getpvalue(u = cvm, eigen = ev)
    res     <- list(Statistic = cvm, pvalue = pvalue)

    return(res)

  }else{

    if (!inherits(fit, 'lm')){
      stop('The fit must be \'lm\' object.')
    }

    if( !is.matrix(fit$x) ){
      stop('fit object must have the design matrix corresponding to the model. Consider setting x = TRUE in lm function to return x matrix.')
    }

    if( !is.vector(fit$y) ){
      stop('fit object must have the used response variable. Consider setting y = TRUE in lm function to return reponse y.')
    }

    x <- fit$x
    y <- fit$y

    temp   <- applyLMNormal(x = x, y = y)
    Score  <- temp$Score
    pit    <- temp$pit
    par    <- temp$par

    # Get Fisher information matrix
    if( hessian ){
      fisher <- getObservedHessMatrixinLMNormal(x, y, par)
    }else{
      fisher <- (n-1)*var(Score)/n
    }


    if( method == 'cvm'){

      # Get Eigen values
      if( gridpit ){
        ev    <- getEigenValues(S = Score, FI = fisher, pit, me = 'cvm')
      }else{
        ev    <- getEigenValues_manualGrid(S = Score, FI = fisher, pit, M = ngrid, me = 'cvm')
      }

      # Get C-v-M statistic
      cvm      <- getCvMStatistic(pit)

      # Get pvalue
      pvalue  <- getpvalue(u = cvm, eigen = ev)

      res     <- list(Statistic = cvm, pvalue = pvalue)

      return(res)

    } else if ( method == 'ad') {

      # Get Eigen values
      if( gridpit ){
        ev    <- getEigenValues(S = Score, FI = fisher, pit, me = 'ad')
      }else{
        ev    <- getEigenValues_manualGrid(S = Score, FI = fisher, pit, M = ngrid, me = 'ad')
      }

      # Get C-v-M statistic
      AD      <- getCvMStatistic(pit)

      # Get pvalue
      pvalue  <- getpvalue(u = AD, eigen = ev)

      res     <- list(Statistic = AD, pvalue = pvalue)

      return(res)


    } else {

      # Calculate both cvm and ad statistics

      # 1. Do cvm calculation
      cvm        <- getCvMStatistic(pit)
      names(cvm) <- 'Cramer-von-Mises Statistic'

      # Get Eigen values
      if( gridpit ){
        ev    <- getEigenValues(S = Score, FI = fisher, pit = pit, me = 'cvm')
      }else{
        ev    <- getEigenValues_manualGrid(S = Score, FI = fisher, pit = pit, M = ngrid, me = 'cvm')
      }

      # Calculate pvalue
      cvm.pvalue  <- getpvalue(u = cvm, eigen = ev)
      names(cvm.pvalue) <- 'pvalue for Cramer-von-Mises test'


      # 2. Do AD calculations
      AD      <- getADStatistic(pit)
      names(AD) <- 'Anderson-Darling Statistic'

      # Get Eigen values
      if( gridpit ){
        ev    <- getEigenValues(S = Score, FI = fisher, pit = pit, me = 'ad')
      }else{
        ev    <- getEigenValues_manualGrid(S = Score, FI = fisher, pit = pit, M = ngrid, me = 'ad')
      }

      # Calculate pvalue
      ad.pvalue  <- getpvalue(u = AD, eigen = ev)
      names(ad.pvalue) <- 'Anderson-Darling test'


      # Prepare a list to return both statistics and their approximate pvalue
      res     <- list(Statistics = c(cvm, AD), pvalue = c(cvm.pvalue, ad.pvalue) )
      return(res)

    }

  }

}
